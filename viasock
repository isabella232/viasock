#!/usr/bin/env python3


import argparse
import concurrent.futures
import errno
import hashlib
import logging
import logging.handlers
import os
import re
import select
import socket
import socketserver
import subprocess
import sys
import threading
import time


### UTILITIES #################################################################


def _now():
    return time.time()


def _mtime(path, default=0):
    """
    Returns the mtime of the file at the specified path. Returns default if
    file does not exist. An OSError is raised if the file cannot be stat'd.
    """
    try:
        return os.stat(path).st_mtime
    except OSError as e:
        if e.errno == errno.ENOENT:
            return default
        raise e


def _makedirs(path):
    try:
        os.makedirs(path)
    except OSError as error:
        if error.errno != errno.EEXIST:
            raise error


def _timeout(stream, timeout):
    if timeout is not None:
        ready, _, _ = select.select((stream,), (), (), timeout)
        if not ready:
            raise _ViasockServerError('process took to long to answer')


def _records(stream, terminator_line_pattern, timeout=None):
    """
    Reads from a file-like object, chopping the data up into records terminated
    by lines matching (after chomping off the line terminator) the given
    terminator pattern. Returns a sequence of the records. Raises
    _IncompleteRecord if the last record does not end with a line matching the
    terminator pattern.
    """
    record = b''
    _timeout(stream, timeout)
    for line in stream:
        record += line
        (chomped,) = line.splitlines()
        if terminator_line_pattern.match(chomped):
            yield record
            record = b''
        _timeout(stream, timeout)
    # TODO what if the process stops sending output mid-line?
    if record:
        raise _IncompleteRecord()


def _fork(fun, *args):
    """
    Spawns a new process that runs the given function with the given arguments.
    """
    if os.fork() == 0:
        os.setsid()
        # next line is to prevent forked process from holding up pipes
        os.close(sys.stdout.fileno())
        fun(*args)
        sys.exit()


class _ViasockError(Exception):

    def __init__(self, message):
        Exception.__init__(self)
        self.message = message


class _ViasockRunError(_ViasockError):
    pass


class _ViasockServerError(_ViasockError):
    pass


class _ViasockClientError(_ViasockError):
    pass


class _IncompleteRecord(Exception):
    pass


### LOGGING ###################################################################


def _set_up_server_logging(log):
    logger = logging.getLogger('viasock.server')
    logger.setLevel(logging.INFO)
    if log is None:
        handler = logging.StreamHandler()
    else:
        handler = logging.handlers.RotatingFileHandler(log, maxBytes=1024*1024,
                                                       backupCount=5)
    logger.addHandler(handler)


### SERVER ####################################################################


class _Handler(socketserver.StreamRequestHandler):

    def handle(self):
        try:
            self.wfile.write(self.server.output_prelude)
            try:
                for input_record in _records(self.rfile,
                                             self.server.input_terminator):
                    # Write input to process asynchronously while already
                    # starting to read the output, otherwise writing might
                    # deadlock:
                    def write():
                        self.server.proc.stdin.write(input_record)
                        self.server.proc.stdin.flush()
                    fut_write = self.server.executor.submit(write)
                    try:
                        output_record = next(self.server.output_records)
                    except StopIteration:
                        raise _ViasockServerError(
                            'process stopped sending output')
                    except _IncompleteRecord:
                        raise _ViasockServerError(
                            'process stopped sending output mid-record')
                    fut_write.result() # raise any exception
                    self.wfile.write(output_record)
            except _IncompleteRecord:
                raise _ViasockServerError(
                    'client did not terminate input record')
        except Exception as e:
            # store any exception so we can give an informative error message
            self.server.exception = e
            # raise it, thereby triggering the server's error handling
            # mechanism
            raise e


class _Server(socketserver.UnixStreamServer):

    def handle_timeout(self):
        self.shutdown_flag = True

    def handle_error(self, request, client_address):
        self.shutdown_flag = True


def _server(socket, program, args, input_terminator, output_terminator,
            output_prelude_length, process_timeout, server_timeout):
    executor = concurrent.futures.ThreadPoolExecutor(2)
    try: # server cleanup in finally clause
        server = _Server(socket, _Handler)
        logging.getLogger('viasock.server').info('[viasock server] started')
        interrupted = False
        try: # process cleanup in finally clause
            proc = None
            # Start process:
            proc = subprocess.Popen([program] + args, stdin=subprocess.PIPE,
                                    stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE)
            # Handle proc.stderr:
            def handle_stderr():
                logger = logging.getLogger('viasock.server')
                for line in _records(proc.stderr, re.compile(rb''),
                                     process_timeout):
                    # Convert line from bytes to str if possible:
                    try:
                        line = line.decode()
                    except UnicodeDecodeError:
                        pass
                    # Chomp line:
                    (line,) = line.splitlines()
                    # Log line:
                    logger.info('[{}] {}'.format(program, line))
            fut_handle_stderr = executor.submit(handle_stderr)
            # Read records from proc.stdout:
            output_records = _records(proc.stdout, output_terminator,
                                      process_timeout)
            # Determine the output prelude:
            output_prelude = b''
            for i in range(output_prelude_length):
                output_prelude += next(output_records)
            # Store things needed by _Handler objects in server:
            server.executor = executor
            server.proc = proc
            server.input_terminator = input_terminator
            server.output_prelude = output_prelude
            server.output_records = output_records
            server.exception = None
            # Server settings:
            server.shutdown_flag = False
            server.timeout = server_timeout
            # Handle requests
            # We could use the serve_forever and shutdown methods. However,
            # that could lead to a race condition where the process crashes,
            # the handler notices and calls shutdown, but the server starts
            # handling another request before shutting down. So we handle
            # requests in a loop and use a shutdown flag, checking whether
            # it is set after every request:
            try:
                while not server.shutdown_flag:
                    server.handle_request()
            except KeyboardInterrupt:
                logging.getLogger('viasock.server').info(
                    '[viasock server] received interrupt signal')
                interrupted = True
            # Error handling:
            if server.exception:
                raise server.exception
        finally:
            if proc is not None and not interrupted:
                proc.stdin.close()
                proc.wait()
                try:
                    fut_handle_stderr.result()
                except BrokenPipeError:
                    raise _ViasockServerError(
                        'process exited unexpectedly with status {}'.format(
                        proc.returncode))
                if proc.returncode != 0:
                    raise _ViasockServerError(
                        'process exited with status {}'.format(
                        proc.returncode))
    finally:
        try:
            os.unlink(socket)
        except FileNotFoundError:
            pass
        logging.getLogger('viasock.server').info('[viasock server] stopped')


### CLIENT ####################################################################


def _client(socket_path, input_terminator, output_terminator,
            output_prelude_length):
    with socket.socket(socket.AF_UNIX) as sock:
        sock.connect(socket_path)
        wfile = sock.makefile('wb')
        rfile = sock.makefile('rb')
        output_records = _records(rfile, output_terminator)
        try:
            for i in range(output_prelude_length):
                sys.stdout.buffer.write(next(output_records))
                if sys.stdout.buffer.isatty():
                    sys.stdout.buffer.flush()
            for input_record in _records(sys.stdin.buffer, input_terminator):
                wfile.write(input_record)
                wfile.flush()
                try:
                    output_record = next(output_records)
                except StopIteration:
                    raise _ViasockClientError('server stopped sending output')
                except _IncompleteRecord:
                    raise _ViasockClientError('server stopped sending output '
                                              'mid-record')
                sys.stdout.buffer.write(output_record)
                if sys.stdout.buffer.isatty():
                    sys.stdout.buffer.flush()
        except _IncompleteRecord:
            raise _ViasockClientError('input record was not terminated')


### RUN #######################################################################


def _socketname(program, args, process_timeout, input_terminator,
                output_terminator, output_prelude_length, server_timeout, log):
    """
    Returns the name for the socket: a hash of the program, its arguments and
    their modification times (or 0 for arguments that don't resolve to
    existing files). The effect is (barring hash collisons) that no two
    commands use the same socket, and a new socket (and therefore a new server)
    is created when the program or some of the files it reads on startup
    change.
    """
    h = hashlib.md5()
    for x in [program] + args:
        h.update(x.encode('UTF-8'))
        h.update(str(_mtime(x)).encode('UTF-8'))
    h.update(str(process_timeout).encode('UTF-8'))
    h.update(input_terminator.pattern)
    h.update(output_terminator.pattern)
    h.update(bytes(output_prelude_length))
    h.update(str(server_timeout).encode('UTF-8'))
    h.update(repr(log).encode('UTF-8'))
    return h.hexdigest()


def _run(program, args, input_terminator, output_terminator,
         output_prelude_length, process_timeout, server_timeout, log):
    _makedirs('.viasock/sockets')
    socket = os.path.join('.viasock/sockets', _socketname(program, args,
        process_timeout, input_terminator, output_terminator,
        output_prelude_length, server_timeout, log))
    success = False
    try:
        _client(socket, input_terminator, output_terminator,
                output_prelude_length)
    except (FileNotFoundError, ConnectionRefusedError) as e:
        # No usable server present, so we need to spawn one.
        if isinstance(e, ConnectionRefusedError):
            # This means the socket file was there, but no server was
            # accepting connections on it. The server probably crashed and
            # left the file behind. So delete it first.
            try:
                print('[viasock run] WARNING: socket file found but connection'
                      ' refused - probably the server crashed earlier. '
                      'Restarting.', file=sys.stderr)
                os.unlink(socket)
            except FileNotFoundError:
                pass
        _fork(_server, socket, program, args, input_terminator,
              output_terminator, output_prelude_length, process_timeout,
              server_timeout)
        # Give the new server some time to start (or for the one started by
        # another viasock run instance to come up, in which case our server
        # will silently go down because the socket is already in use):
        time.sleep(1)
        # Use the new server or die trying:
        try:
            _client(socket, input_terminator, output_terminator,
                output_prelude_length)
        except (FileNotFoundError, ConnectionRefusedError):
            raise _ViasockRunError('[viasock run] ERROR: 1s after spawning a '
                                   'server, it is still not accepting '
                                   'connections. Something is probably wrong.')


### MAIN ######################################################################


def _main():
    parser = argparse.ArgumentParser(description='Avoid startup overhead by '
        'automagically serverizing your scripts.')
    subparsers = parser.add_subparsers(title='subcommands', dest='subcommand',
                                       description='valid subcommands')
    parser_run = subparsers.add_parser('run',
        help='run a command via a socket server, which is automatically '
             'started if needed (this should be the only subcommand you need)')
    parser_server = subparsers.add_parser('server',
        help='run a command wrapped in a socket server')
    parser_server.add_argument('socket',
        help='the socket file the server should listen on')
    parser_client = subparsers.add_parser('client',
        help='connect to a socket for input and output')
    parser_client.add_argument('socket',
        help='the socket file the client should connect to')
    for p in (parser_run, parser_server):
        p.add_argument('program', help='the program to run')
        p.add_argument('args', help='the arguments to the program',
                       nargs=argparse.REMAINDER)
        p.add_argument('-w', '--process-timeout', type=float, default=None,
                       help='how long to wait (in s) for the output record '
                       'after sending an input record, before aborting with a '
                       'timeout error -- default is forever')
        p.add_argument('-W', '--server-timeout', type=float, default=60,
                       help='after how many seconds to shut down the server '
                       'when there are no requests -- default is 60')
        p.add_argument('-l', '--log', help='server log file path prefix')
    for p in (parser_run, parser_server, parser_client):
        p.add_argument('-t', '--input-terminator', default=r'',
                       metavar='PATTERN',
                       help='pattern used to recognize an input line that is '
                            'the last of a record -- for 1 line = 1 record '
                            '(default) use \'\' (matches any line); for '
                            'records terminated by an empty line use \'^$\'; '
                            'for EOS on a line by itself as record terminator '
                            'use \'^EOS$\'; etc.')
        p.add_argument('-T', '--output-terminator', default=r'',
                       metavar='PATTERN',
                       help='pattern used to recognize an output line that is '
                            'the last of a record -- for 1 line = 1 record '
                            '(default) use \'\' (matches any line); for '
                            'records terminated by an empty line use \'^$\'; '
                            'for EOS on a line by itself as record terminator '
                            'use \'^EOS$\'; etc.')
        p.add_argument('-P', '--output-prelude', type=int, default=0,
                       metavar='INT',
                       help='how many records at the beginning of the '
                            'output are prelude and should be repeated '
                            'for every client')
    args = parser.parse_args()
    if args.subcommand in ('run', 'server', 'client'):
        input_terminator = re.compile(args.input_terminator.encode())
        output_terminator = re.compile(args.output_terminator.encode())
    try:
        if args.subcommand == 'run':
            _set_up_server_logging(args.log)
            _run(args.program, args.args, input_terminator, output_terminator,
                 args.output_prelude, args.process_timeout,
                 args.server_timeout, args.log)
        elif args.subcommand == 'server':
            _set_up_server_logging(args.log)
            _server(args.socket, args.program, args.args, input_terminator,
                    output_terminator, args.output_prelude,
                    args.process_timeout, args.server_timeout)
        elif args.subcommand == 'client':
            _client(args.socket, input_terminator, output_terminator,
                    args.output_prelude)
        else:
            parser.print_help()
    except _ViasockRunError as e:
        print('[viasock run] ERROR: {}'.format(e.message), file=sys.stderr)
        sys.exit(1)
    except _ViasockServerError as e:
        logging.getLogger('viasock.server').error(
            '[viasock server] ERROR: {}'.format(e.message))
        sys.exit(1)
    except _ViasockClientError as e:
        print('[viasock client] ERROR: {}'.format(e.message), file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    _main()
